for (i in codelist){
print(i)
}
codelist[1]
codelist[1]
codelist(1)
codelist[[1]]
str(codelist)
codeno
length(codelist)
codelist <- as.vector(codeno) #코드명들을 벡터형으로 변경
codelist
str(codelist)
codelist <- as.vector(codeno) #코드명들을 벡터형으로 변경
codelist
str(codelist)
codelist <- as.vector(codeno) #코드명들을 벡터형으로 변경
str(codelist)
bbb <- c(1,2,3)
str(bbb)
codelist <- as.numeric(codeno) #코드명들을 벡터형으로 변경
codeno
length(codeno)
codelist <- as.list(codeno) #코드명들을 벡터형으로 변경
str(codelist)
unlist(codelist)
str(codelist)
unlist(codelist)
codelist <- as.vector(as.matrix(codeno)) #코드명들을 벡터형으로 변경
str(codelist)
codelist
str(codelist)
for (i in codelist){
print(i)
}
codelist2<- for (i in codelist){
cat(i,".KS")
}
codelist2
codelist[1]
for (i in length(codelist)){
codelist[i]
}
for (i in length(codelist)){
cat(codelist[i])
}
length(codelist)
for (i in length(codelist)){
cat([i])
}
for (i in length(codelist)){
cat(i)
}
for (i in 3){
cat(i)
}
for (i in 1:3){
cat(i)
}
for (i in 1:length(codelist)){
cat(i)
}
length(codelist)
for (i in 1:length(codelist)){
cat(codelist[1].KS)
}
for (i in 1:length(codelist)){
cat(codelist[1], '.KS')
}
for (i in 1:length(codelist)){
cat(codelist[1], '.KS'/n)
}
for (i in 1:length(codelist)){
cat(codelist[1], '.KS/n')
}
for (i in 1:length(codelist)){
cat(codelist[1], '.KS' \n)
}
for (i in 1:length(codelist)){
<- cat(codelist[i], '.KS')
}
for (i in 1:length(codelist)){
cat(codelist[i], '.KS')
}
ss <- tq_get("251270.KS")
ss
for (i in 1:length(codelist)){
ks <- cat(codelist[i], '.KS')
st <- tq-get(ks)
print(st)
}
for (i in 1:length(codelist)){
ks <- cat(codelist[i], '.KS')
st <- tq_get(ks)
print(st)
}
for (i in 1:length(codelist)){
ks <- cat(codelist[i], '.KS'),
st <- tq_get(ks),
print(st)
}
for (i in 1:length(codelist)){
ks <- cat(codelist[i], '.KS'),
}
for (i in 1:length(codelist)){
cat(codelist[i], '.KS'),
}
for (i in 1:length(codelist)){
cat(codelist[i], '.KS')
}
cat(codelist[1], '.KS')
cat(codelist[1],'.KS')
ssss<- cat(codelist[1],'.KS')
ss <- tq_get(ssss)
ss
ssss<- print(codelist[1],'.KS')
c(a*10)
c
c(a*10)
c('a'*10)
c
c('a')
c
c('a')
c('a'*12)
c('a':10)
c(10, times=10)
c
aa <- c(10, times=10)
aa
aa <- c('a', times=10)
aa
aa <- c(1:1, times=10)
aa
aa <- rep('a', times=10)
aa
code
codelist
aa <- rep('.KS', times=798)
aa
ksr <- rep('.KS', times=798) # .KS 문자열 벡터
ksr
ksr <- rep('KS', times=798) # .KS 문자열 벡터
ksr <- rep('KS', times=798) # .KS 문자열 벡터
ksr
codelist
pcode <- str_c(codelist, ksr, sep = '.')
library(stringr)
ksr <- rep('KS', times=798) # .KS 문자열 벡터
ksr
pcode <- str_c(codelist, ksr, sep = '.')
pcode
pcode[1]
for (i in 1:length(codelist)){
pcode[i]
}
for (i in 1:length(codelist)){
cat(pcode[i])
}
for (i in 1:length(codelist)){
cat(tq_get(pcode[i]))
}
for (i in 1:length(codelist)){
(tq_get(pcode[i]))
}
sss<- for (i in 1:length(codelist)){
(tq_get(pcode[i]))
}
sss
i=5
aaaaa<- tq_get(pcode[i])
aaaaa
i=5
aaaaa<- tq_get(pcode[i])
aaaaa
pcode[1]
i=5
aaaaa<- tq_get(pcode[i])
aaaaa
aaaaa<- tq_get(pcode[1])
aaaaa
tq_get(pcode[1])
pcode[1]
aaaaa<- tq_get("095570.KS")
aaaaa
ss <- tq_get("251270.KS")
ss
aaaaa<- tq_get(pcode[5])
aaaaa
pcode[5]
sss<- for (i in 1:length(codelist)){
(tq_get(pcode[i]))
}
sss
str(sss)
sss<- for (i in 1:2){
(tq_get(pcode[i]))
}
sss
sss<- for (i in 1:2){
return(tq_get(pcode[i]))
}
sss
(tq_get(pcode[i])
(tq_get(pcode[i])
aaa <- (tq_get(pcode[i])
sss<- for (i in 1:2){
result = (tq_get(pcode[i]))
print(result)
}
sss
sss<- for (i in 1:2){
result = (tq_get(pcode[i]))
print(result)
return
}
sss
sss<- for (i in 1:2){
result = (tq_get(pcode[i]))
print(result)
return()
}
sss
sss<- for (i in 1:2){
result = (tq_get(pcode[i]))
print(result)
return(list(result))
}
sss
sss<- for (i in 1:2){
result = (tq_get(pcode[i]))
print(result)
}
sss
sss<- for (i in 1:3){
result = (tq_get(pcode[i]))
print(result)
}
sss
str(sss)
asd<- for (i in 1:3){
result = (tq_get(pcode[i]))
print(result)
}
asd
empty_list = list()
empty_list
empty_list = list() #빈 리스트
empty_list
str(empty_list)
for (i in 1:3){
result = (tq_get(pcode[i]))
empty_list <- result
}
empty_list
empty_list = list() #빈 리스트
for (i in 1:3){
result = (tq_get(pcode[i]))
empty_list <- empty_list + result
}
empty_list
emptyl = list() #빈 리스트
emptyl
str(emptyl)
emptyl = list('') #빈 리스트
emptyl
emptyl = list() #빈 리스트
emptyl
str(emptyl)
for (i in 1:3){
result = (tq_get(pcode[i]))
emptyl <- emptyl + result
}
emptyl
for (i in 1:3){
result = (tq_get(pcode[i]))
emptyl = emptyl + result
}
emptyl = list('') #빈 리스트
emptyl
str(emptyl)
for (i in 1:3){
result = (tq_get(pcode[i]))
emptyl = emptyl + result
}
for (i in 1:3){
result = (tq_get(pcode[i]))
reulst_list <- as.list(result)
emptyl = emptyl + reulst_list
}
result = (tq_get(pcode[1]))
str(result)
result_test = (tq_get(pcode[1]))
str(result_test) #data.frame
as.list(result_test)
str(result_test) #data.frame
result = (tq_get(pcode[i]))
result
result[2,3,4]
result = (tq_get(pcode[i]))
result[2,3,4]
result[,,1]
result[,1]
result[,2]
result[,(3,4)]
result[,(3:4)]
result[,c(2,3,6)]
for (i in 1:3){
result = (tq_get(pcode[i])) #지금 이것의 결과는 data.frame
result2 <- result[,c(2,3,6)]
}
for (i in 1:3){
result = (tq_get(pcode[i])) #지금 이것의 결과는 data.frame
result2 <- result[,c(2,3,6)]
}
for (i in 1:3){
result = (tq_get(pcode[i])) #지금 이것의 결과는 data.frame
result2 <- result[,c(2,3,6)]
print(result2)
}
str(result2)
for (i in 1:3){
result = (tq_get(pcode[i])) #지금 이것의 결과는 data.frame
result2 <- result[,c(2,3,6)] #data.frame
emptyl[i] <-  result2  #이 리절트2를 이름을 코드번호로 해서 새로운 리스트에 추가하기.
}
emptyl
result2
# (1) matrix 생성
x <- matrix(1:9, nrow=3, by=T)
# (2) matrix 대상 유클리드 거리 생성 함수
# 형식) dist(x, method="euclidean") -> x : numeric matrix, data frame
dist <- dist(x, method="euclidean") # method 생략가능
dist
# (3) 유클리드 거리 계산 식
# 관측대상 p와 q의 대응하는 변량값의 차의 제곱의 합에 sqrt 적용
sqrt(sum((x[1,] - x[2,])**2))
# 5.196152
sqrt(sum((x[1,] - x[3,])**2))
# (1) 군집분석(Clustering)분석을 위한 패키지 설치
install.packages("cluster") # hclust() : 계층적 클러스터 함수 제공
library(cluster) # 일반적으로 3~10개 그룹핑이 적정
# (2) 데이터 셋 생성
r <- runif(15, min = 1, max = 50)
x <- matrix(r, nrow=5, by=T)
x
# (3) matrix 대상 유클리드 거리 생성 함수
dist <- dist(x, method="euclidean") # method 생략가능
dist
mean(x[1,])
mean(x[5,])
# (4) 유클리드 거리 matrix를 이용한 클러스터링
hc <- hclust(dist) # 클러스터링 적용
hc
help(hclust)
plot(hc) # 클러스터 플로팅(Dendrogram) -> 1과2 군집(클러스터) 형성
plot(hc) # 클러스터 플로팅(Dendrogram) -> 1과2 군집(클러스터) 형성
#<실습> 중1학년 신체검사 결과 군집분석
#---------------------------------------------
body <- read.csv("c:/ITWILL/2_Rwork/Part-IV/bodycheck.csv")
names(body)
idist <- dist(body)
idist
hc <- hclust(idist)
plot(hc, hang=-1) # 음수값 제외
# 3개 그룹 선정, 선 색 지정
rect.hclust(hc, k=3, border="red") # 3개 그룹 선정, 선 색 지정
# (3) matrix 대상 유클리드 거리 생성 함수
dist <- dist(x, method="euclidean") # method 생략가능
dist
# (4) 유클리드 거리 matrix를 이용한 클러스터링
hc <- hclust(dist) # 클러스터링 적용
hc
plot(hc) # 클러스터 플로팅(Dendrogram) -> 1과2 군집(클러스터) 형성
x
plot(hc, hang=-1) # hang=-1 음수값 제외
plot(hc, hang=-1) # hang=-1 음수값 제외
idist <- dist(body)
idist
hc <- hclust(idist)
plot(hc, hang=-1) # hang=-1 음수값 제외
# 3개 그룹 선정, 선 색 지정
rect.hclust(hc, k=3, border="red") # 3개 그룹 선정, 선 색 지정
# 각 그룹별 서브셋 만들기
g1<- subset(body, 번호==15| 번호==1| 번호==4| 번호==8 | 번호==10)
g2<- subset(body, 번호==11| 번호==3| 번호==5| 번호==6 | 번호==14)
g3<- subset(body, 번호==2| 번호==9| 번호==7| 번호==12 | 번호==13)
# 각 그룹별 특징
summary(g1)
summary(g2)
summary(g3)
# 1) 유클리드 거리 계산
idist<- dist(iris[1:4]) # dist(iris[, -5])
# 2) 계층형 군집분석(클러스터링)
hc <- hclust(idist)
hc
plot(hc, hang=-1)
rect.hclust(hc, k=3, border="red") # 3개 그룹수
# 3) 그룹수 만들기 : cutree()함수 -> 지정된 그룹수 만큼 자르기
# 형식) cutree(계층형군집결과, k=그룹수) -> 그룹수 만큼 자름
ghc<- cutree(hc, k=3) # stats 패키지 제공
ghc #  150개(그룹을 의미하는 숫자(1~3) 출력)
# 4) iris에서 ghc 컬럼 추가
iris$ghc <- ghc
table(iris$ghc) # ghc 빈도수
head(iris,60) # ghc 칼럼 확인
# 5) 그룹별 요약통계량 구하기
g1 <- subset(iris, ghc==1)
summary(g1[1:4])
g2 <- subset(iris, ghc==2)
summary(g2[1:4])
g3 <- subset(iris, ghc==3)
summary(g3[1:4])
idist <- idst(iris[1:4])
idist <- iris[1:4]
str(idist)
iris[1:4] # 4개변수 전체
idist <- matrix(iris[1:4], nrow=4, by=T)
idist
idist <- matrix(iris[1:4], nrow=4)
idist
idist <- matrix(iris[1:4], ncol=4)
idist
# 1) data set 준비
library(ggplot2)
data(diamonds)
nrow(diamonds) # [1] 53940
t <- sample(nrow(diamonds),1000) # 1000개 셈플링
test <- diamonds[t, ] # 1000개 표본 추출
dim(test) # [1] 1000 10
head(test) # 검정 데이터
mydia <- test[c("price","carat", "depth", "table")] # 4개 칼럼만 선정
head(mydia)
# 2) 계층적 군집분석(탐색적 분석)
result <- hclust(dist(mydia), method="average") # 평균거리 이용
result
plot(result, hang=-1) # hang : -1 이하 값 제거
names(result2) # cluster 칼럼 확인
# 3) 비계층적 군집분석(확인적 분석) - kmeans()함수 이용
# - 확인적 군집분석 : 군집의 수를 알고 있는 경우
result2 <- kmeans(mydia, 3)
result2
names(result2) # cluster 칼럼 확인
result2$cluster # 각 케이스에 대한 소속 군집수(1,2,3)
result2$cluster # 각 케이스에 대한 소속 군집수(1,2,3)
result2$centers
table(result2$cluster)
# 5) 변수 간의 상관성 보기
plot(mydia[,-5])
# 4) 원형데이터에 군집수 추가
mydia$cluster <- result2$cluster
head(mydia) # cluster 칼럼 확인
# 5) 변수 간의 상관성 보기
plot(mydia[,-5])
# 6) 비계층적 군집시각화
plot(mydia$carat, mydia$price)
plot(mydia$carat, mydia$price, col=mydia$cluster)
# 중심점 표시 추가
result2$centers # Cluster means 값을 갖는 컬럼
# 각 그룹의 중심점에 포인트 추가
points(result2$centers[,c("carat", "price")], col=c(3,1,2), pch=8, cex=5)
setwd("c:/ITWILL/2_Rwork/Part-IV")
sales <- read.csv("product_sales.csv", header=TRUE)
head(sales)
# 단계1: 비계층적 군집분석 : 3개 군집으로 군집화
cluster <- kmeans(sales, center = 3)
# 단계1: 비계층적 군집분석 : 3개 군집으로 군집화
cluster <- kmeans(sales, centers = 3)
names(cluster)
# 단계2: 원형데이터에 군집수 추가
sales$cluster <- cluster$cluster
head(sales)
tail(sales)
table(sales$cluster)
# 단계3 : tot_price 변수와 가장 상관계수가 높은 변수와 군집분석 시각화
cor(sales[-5]) #
plot(sales$tot_price, sales$visit_count,
col=sales$cluster,
main = "상품구매 군집분석")
# 단계4. 군집의 중심점 표시
points(cluster$centers[,c('tot_price','avg_price')],
col=c(3,1,2), pch=8, cex=5)
plot(sales$tot_price, sales$avg_price,
col=sales$cluster,
main = "상품구매 군집분석")
# 단계4. 군집의 중심점 표시
points(cluster$centers[,c('tot_price','avg_price')],
col=c(3,1,2), pch=8, cex=5)
#########################
## 군집수 결정방법
#########################
install.packages("NvClust")
#########################
## 군집수 결정방법
#########################
install.packages("NbClust")
library(NbClust)
iris_max <- as.matrix(iris[-5])
iris_max
?NbClust
data("iris")
iris_max <- as.matrix(iris[-5])
iris_max
?NbClust
NbClust(iris_max, distance = "euclidean", min.nc = 2, max.nc = 15,
method = "complete")
dim(iris_max) #150
nc <- NbClust(iris_max, distance = "euclidean", min.nc = 2, max.nc = 15,
method = "complete")
nc
names(nc)
table(nc$Best.nc[1,])
