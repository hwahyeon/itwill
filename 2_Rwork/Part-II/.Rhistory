opar
opar <- par(mfrow=c(2,2))
opar
opar <- par(mfrow=c(1,2))
opar
dim(opar)
opar <- par(mfrow=c(1,2))
plot(Ozone$V8, Ozone$V9, xlab='Sandburg Temperature', ylab='El Monte Temperature',
main="Ozone", pch=20)
plot(Ozone$V8, Ozone$V9, xlab='Sandburg Temperature', ylab='El Monte Temperature',
main="Ozone", pch='+', cex=0.5, col='red')
opar <- par(mfrow=c(2,2)) #1행 2열로 그래프 그리기
plot(Ozone$V8, Ozone$V9, xlab='Sandburg Temperature', ylab='El Monte Temperature',
main="Ozone", pch=20)
plot(Ozone$V8, Ozone$V9, xlab='Sandburg Temperature', ylab='El Monte Temperature',
main="Ozone", pch='+', cex=0.5, col='red')
plot(Ozone$V8, Ozone$V9, xlab='Sandburg Temperature', ylab='El Monte Temperature',
main="Ozone", pch=20)
plot(Ozone$V8, Ozone$V9, xlab='Sandburg Temperature', ylab='El Monte Temperature',
main="Ozone", pch='+', cex=0.5, col='red')
opar
#형식) dcast(Dataset, row ~ col, func) 포뮬라(~)라는 기호를 사용하는 것이 특징.
wide <- dcast(data, Customer_ID ~ Date, sum)
data <- read.csv(file.choose()) #Part-II
data
dim(data) #22  3
# Data : 구매일자(col)
# ID : 고객 구분자(row)
# Buy : 구매수량
names(data)
#형식) dcast(Dataset, row ~ col, func) 포뮬라(~)라는 기호를 사용하는 것이 특징.
wide <- dcast(data, Customer_ID ~ Date, sum)
library(reshape2)
#형식) dcast(Dataset, row ~ col, func) 포뮬라(~)라는 기호를 사용하는 것이 특징.
wide <- dcast(data, Customer_ID ~ Date, sum)
library(reshape2)
#형식) dcast(Dataset, row ~ col, func) 포뮬라(~)라는 기호를 사용하는 것이 특징.
wide <- dcast(data, Customer_ID ~ Date, sum)
wide
str(wide)
library(ggplot2)
data(mpg) #자동차 연비
str(mpg)
# 실습 데이터 읽어오기
setwd("C:/ITWILL/2_Rwork/Part-II")
dataset <- read.csv("dataset.csv", header=TRUE) # 헤더가 있는 경우
# (1) 데이터 셋 구조
names(dataset) # 변수명(컬럼)
attributes(dataset) # names(), class, row.names
str(dataset) # 데이터 구조보기
dim(dataset) # 차원보기 : 300 7
nrow(dataset) # 관측치 수 : 300
length(dataset) # 칼럼수 : 7
length(dataset$resident) # 300
# 1) 결측지 제거
price2 <- na.omit(dataset$price) #특정 칼럼
length(price2) #270
price2
dataset
library(dplyr)
(dplyr)
library(dplyr)
# 1) 범주형(집단) 변수
gender <- dataset$gender
gender
#이상치 발견 : table(), 차트
table(gender)
(gender)
# gender
# 0   1   2   5
# 2 173 124   1
pit(table(gender))
# gender
# 0   1   2   5
# 2 173 124   1
pie(table(gender))
#이상치 정제
dataset <- subset(dataset, gender==1, gender==2)
pie(table(dataset$gender))
#이상치 정제
dataset <- subset(dataset, gender==1, gender==2)
pie(table(dataset$gender))
# gender
# 0   1   2   5
# 2 173 124   1
pie(table(gender))
#이상치 정제
dataset <- subset(dataset, gender==1, gender==2)
pie(table(dataset$gender))
#이상치 정제
dataset <- subset(dataset, gender==1 | gender==2)
pie(table(dataset$gender))
#이상치 정제
dataset <- subset(dataset, gender==1 | gender==2)
pie(table(dataset$gender))
# gender
# 0   1   2   5
# 2 173 124   1
pie(table(gender))
#이상치 정제
dataset <- subset(dataset, gender==1 | gender==2)
pie(table(dataset$gender))
# gender
# 0   1   2   5
# 2 173 124   1
pie(table(gender))
#이상치 정제
dataset <- subset(dataset, gender==1 | gender==2)
pie(table(dataset$gender))
#이상치 정제
dataset <- subset(dataset, gender==1 | gender==2)
dataset
#이상치 정제
dataset <- subset(dataset, gender==1 or gender==2)
#이상치 발견 : table(), 차트
table(gender)
# gender
# 0   1   2   5
# 2 173 124   1
pie(table(gender))
# gender
# 0   1   2   5
# 2 173 124   1
pie(table(gender))
dataset
# 실습 데이터 읽어오기
setwd("C:/ITWILL/2_Rwork/Part-II")
dataset <- read.csv("dataset.csv", header=TRUE) # 헤더가 있는 경우
dataset
#이상치 정제
dataset <- subset(dataset, gender==1 | gender==2)
pie(table(dataset$gender))
pie(table(dataset$gender))
# 2) 연속형 변수
price <- dataset$price
length(price)
# 2) 연속형 변수
price <- dataset$price
length(price)
plot(price)
# 2) 연속형 변수
price <- dataset$price
#그래프를 보고 정제할 것들을 대략 살펴볼 수 있다.
price
#그래프를 보고 정제할 것들을 대략 살펴볼 수 있다.
summary(price)
# 2~10 정상 범주라고 하고 나머지를 정제하시오.
dataset2 <- subset(dataset, price >= 2 & price <= 10)
pie(dataset2)
plot(dataset2)
dim(dataset2)
plot(dataset2$price)
boxplot(dataset2$price)
# dataset2 : age(20~69)
dataset2 <- subset(dataset, age>=20 & age<=69)
plot(dataset2)
plot(dataset2$age)
boxplot(dataset2$age)
# 3) 이상치 발견이 어려운 경우
boxplot(dataset2$price)
boxplot(dataset2$price)$stats
subset(dataset, price >= 2.1& price <= 7.9)
dataset3 <- subset(dataset, price >= 2.1& price <= 7.9)
boxplot(dataset3)
dataset3 <- subset(dataset$price, price >= 2.1& price <= 7.9)
boxplot(dataset3)
boxplot(re)$stats
re <- subset(dataset$price, price >= 2.1& price <= 7.9)
boxplot(re)$stats
re <- subset(dataset, price >= 2.1& price <= 7.9)
boxplot(re$price)$stats
# [실습]
library(ggplot2)
str(mpg)
hwy <- mpg$hwy
length(hwy)
boxplot(hwy)$stats
mpg_df <- subset(mpg, hwy >= 12 & hwy <=37)
boxplot(mpd_df$why)
boxplot(mpd_df$hwy)
mpg_df <- subset(mpg, hwy >= 12 & hwy <=37)
boxplot(mpd_df$hwy)
boxplot(mpg_df$hwy)
dim(mpg_df)
# 정제 방법2) NA 처리
ifelse(mpg$hwy < 12 | mgp$hwy > 37, NA, mpg$hwy)
# 정제 방법2) NA 처리
ifelse(mpg$hwy < 12 | mpg$hwy > 37, NA, mpg$hwy)
# 정제 방법2) NA 처리
mpg$hwy2 <- ifelse(mpg$hwy < 12 | mpg$hwy > 37, NA, mpg$hwy)
mpg[c('hwy', 'hwy2')]
mpg[c('hwy', 'hwy2')]
mpg_df <- as.data.frame(mpg)
mpg[c('hwy', 'hwy2')]
mpg_df
mpg_df[c('hwy', 'hwy2')]
# 1) 데이터 가독성(1,2)
dataset$gender2[dataset$gender==1] <- "남자"
dataset$gender2[dataset$gender==2] <- "여자"
head(dataset)
head(dataset2)
dataset2$resident2[dataset2$resident==1] <- "1.서울특별시" #숫자가 없으면 우선순위가 안되서 붙이는 것.
dataset2$resident2[dataset2$resident==2] <- "2.인천광역시"
dataset2$resident2[dataset2$resident==3] <- "3.대전광역시"
dataset2$resident2[dataset2$resident==4] <- "4.대구광역시"
dataset2$resident2[dataset2$resident==5] <- "5.시구군"
head(dataset2)
# 2) 척도 변경 : 연속형 -> 범주형
range(dataset2$age)
#20~30 : 청년층, 31~55 : 중년층, 56~ : 장년층
dataset2[dataset2$age<=30] <- "청년층"
dataset2[dataset2$age>30&dataset2$age<=55] <- "중년층"
dataset2[dataset2$age>55] <- "장년층"
#20~30 : 청년층, 31~55 : 중년층, 56~ : 장년층
dataset2$age2[dataset2$age<=30] <- "청년층"
dataset2$age2[dataset2$age>30&dataset2$age<=55] <- "중년층"
dataset2$age2[dataset2$age>55] <- "장년층"
head(dataset2)
# 3) 역코딩 : 1->5, 5->1 // 만족도 평가
table(dataset2$survey)
survey <- dataset2$survey
survey
csurvey <- 6 - survey
csurvey <- 6 - survey #역코딩
dataset2$survey <- csurver
dataset2$survey <- csurvey
table(dataset$survey)
# 01. 본문에서 생성된 dataset2의 직급(position) 칼럼을 대상으로 1급 -> 5급, 5급 -> 1급 형식으로
# 역코딩하여 position2 칼럼에 추가하시오.
ex01<-dataset2$position
# 02. dataset2의 resident 칼럼을 대상으로 NA 값을 제거한 후 dataset3 변수에 저장하시오.
ex02 <- dataset2$resident,
# 03. dataset3의 gender 칼럼을 대상으로 1->"남자", 2->"여자" 형태로 코딩 변경하여
# gender2 칼럼에 추가하고, 파이 차트로 결과를 확인하시오.
# 04. 나이를 30세 이하 -> 1, 31~55 -> 2, 56이상 -> 3 으로 리코딩하여 age3 칼럼에 추가한 후
# age, age2, age3 칼럼만 확인하시오.
dataset2$age3[dataset2$age<=30] <- 1
dataset2$age3[dataset2$age>30&dataset2$age<=55] <- 2
dataset2$age3[dataset2$age>55] <- 3
head(dataset2)
ss <- dataset2(resident, !is.na(resident))
dataset2
ss <- dataset2$resident, !is.na(resident)
dataset3 <- subset(dataset2, !is.na(resident))
head(dataset3)
dataset3$gender2[dataset$gender==1] <- "남자"
dataset3$gender2[dataset$gender==1] <- "여자"
dataset3$gender2[dataset3$gender==1] <- "남자"
dataset3$gender2[dataset3$gender==1] <- "여자"
dataset3
1
1
dataset3$gender2[dataset3$gender==1] <- "남자"
dataset3$gender2[dataset3$gender==2] <- "여자"
dataset3
# (1) 정제된 데이터 저장
setwd('C:/ITWILL/2_Rwork/output')
write.csv(dataset3, 'cleanData.csv', row.names = F)
# (2) 저장된 파일 불러오기/확인
new_data <- read.csv('cleanData.csv')
head(new_data)
library(ggplot2)
str(mtcars) # 'data.frame':	32 obs. of  11 variables:
# (1) 이상치 통계
boxplot(mtcars$qsec)$stat
# (1) 이상치 통계
boxplot(mtcars$qsec)$stats
# 01. 본문에서 생성된 dataset2의 직급(position) 칼럼을 대상으로 1급 -> 5급, 5급 -> 1급 형식으로
# 역코딩하여 position2 칼럼에 추가하시오.
table(dataset2$position)
#1차 역코딩
cpos <- 6-dataset2$position
# 02. dataset2의 resident 칼럼을 대상으로 NA 값을 제거한 후 dataset3 변수에 저장하시오.
dim(dataset2)
dataset2[c('age','age2','age3')]
# (2) 서브셋 생성
mtcars_db <- subset(mtcars, qsec >= 14.5 & qsec <=20.22)
# (3) 정제 결과 확인
plot(mtcars_db$qsec)
boxplot(mtcars_db$qsec)
# 5. 탐색적 분석을 위한 시각화
# - 변수 같의 관계분석
#wd : working directory
setwd("C:\\ITWILL\\2_Rwork\\Part-II")
new_data <- read.csv("new_data.csv")
dim(new_data)
str(new_data)
# 거주지역(5) vs 성별(2)
tab <- table(new_data$resident2, new_data$gender2)
# 거주지역(5) vs 성별(2)
tab1 <- table(new_data$resident2, new_data$gender2)
#거주 지역에 따른 성별의 분포 or 성별에 따른 거주지역 분포
tab1
barplot(tab1, beside = T, horiz = T,
col = rainbow(5), main="성별에 따른 거주지역 분포 현황")
barplot(tab1, beside = T, horiz = T,
col = rainbow(5), main="성별에 따른 거주지역 분포 현황",
legend = row.names(tab1))
barplot(tab1, beside = T, horiz = T,
col = rainbow(5), main="성별에 따른 거주지역 분포 현황",
legend = row.names(tab1))
tab2 <- table(new_data$gender2,new_data$resident2)
tab2
barplot(tab2, beside = T, horiz = T,
col = rainbow(5), main="성별에 따른 거주지역 분포 현황",
legend = row.names(tab1))
barplot(tab2, beside = T, horiz = T,
col = rainbow(2), main="거주지역에 따른 성별 분포 현황",
legend = row.names(tab1))
barplot(tab2, beside = T, horiz = T,
col = rainbow(2), main="거주지역에 따른 성별 분포 현황",
legend = row.names(tab2))
barplot(tab2, beside = T, horiz = T,
col = rainbow(2), main="거주지역에 따른 성별 분포 현황",
legend = row.names(tab2))
mosaicplot(tab, col=rainbow(5))
#정사각형 기준
mosaicplot(tab, col=rainbow(5),
main = "성별에 따른 거주지역 분포 현황")
#고급 시각화 : 직업유형(범주형) vs 나이(범주형)
library(ggplot2)
ggplot(data = new_data, aes(x=job2, fill=age2))
obj + geom_bar
# 미적 객체 생성
obj <- ggplot(data = new_data, aes(x=job2, fill=age2)) #x축을 job2로 만든다는 것.
obj + geom_bar
# 미적 객체 생성
obj <- ggplot(data = new_data, aes(x=job2, fill=age2)) #x축을 job2로 만든다는 것.
obj + geom_bar()
obj + geom_bar(position = fill)
obj + geom_bar(position = fill)
obj + geom_bar(position = "fill")
table(new_data$job2, new_data$age2, useNA = 'ifany') #결측치까지 넣어줌
install.packages("lattice")
#나이(비율) vs 직업유형(명목)
#형식 densityplot(y ~ x)
densityplot(y ~ age, data=new_data)
library(lattice) #격자를 나타냄.
#나이(비율) vs 직업유형(명목)
#형식 densityplot(y ~ x)
densityplot(y ~ age, data=new_data)
library(lattice) #격자를 나타냄.
#나이(비율) vs 직업유형(명목)
#형식 densityplot(y ~ x)
densityplot( ~ age, data=new_data)
#나이(비율) vs 직업유형(명목)
#형식 densityplot(y ~ x)
densityplot( ~ age, groups = job2, data=new_data)
densityplot( ~ age, groups = job2, data=new_data, auto.key = T)
# (1) 구매금액을 성별과 직급으로 분류
densityplot(~ price|factor(gender2),
groups = position2, data = new_data,
auto.key = T)
densityplot(~ price|factor(postion2),
groups = gender2,
data = new_data,
auto.key = T)
densityplot(~ price|factor(position2),
groups = gender2,
data = new_data,
auto.key = T)
# (1) 숫자형 vs 숫자형
cor(new_data$age, new_data$price) #NA
new_data2 <- na.omit(new_data)
new_data2 <- na.omit(new_data)
cor(new_data2$age, new_data2$price)
# 0.0881251 : +-0.3~0.4 이상이어야지 어느 정도 상관성이 있다고 볼 수 있다.
plot(new_data2$age, new_data2$price)
# (2) 숫자형 vs 숫자형 vs 범주형(성별)
xyplot(price ~ age : factor(gender2), data = new_data)
# (2) 숫자형 vs 숫자형 vs 범주형(성별)
xyplot(price ~ age : factor(gender2), data = new_data)
# (2) 숫자형 vs 숫자형 vs 범주형(성별)
xyplot(price ~ age : factor(gender2), data = new_data)
# (2) 숫자형 vs 숫자형 vs 범주형(성별)
xyplot(price ~ age | factor(gender2), data = new_data)
user_data <- read.csv("user_data.csv")
str(user_data)
# 1) 1:1 : 기존칼럼 -> 새로운 칼럼(1)
# 더미변수 : 1,2 -> 1,  //  3,4 -> 2 집 타입을 이렇게 묶을 것
ifelse(user_data$house_type==1 or house_type==2, 1, 2)
# 1) 1:1 : 기존칼럼 -> 새로운 칼럼(1)
# 더미변수 : 1,2 -> 1,  //  3,4 -> 2 집 타입을 이렇게 묶을 것
ifelse(user_data$house_type==1 | house_type==2, 1, 2)
user_data <- read.csv("user_data.csv")
str(user_data) #'data.frame':	400 obs. of  5 variables:
# 1) 1:1 : 기존칼럼 -> 새로운 칼럼(1)
# 더미변수 : 1,2 -> 1,  //  3,4 -> 2 집 타입을 이렇게 묶을 것
ifelse(user_data$house_type==1 | house_type==2, 1, 2)
user_data$house_type2 <-
table(user_data$house_type)
# 1) 1:1 : 기존칼럼 -> 새로운 칼럼(1)
# 더미변수 : 1,2 -> 1,  //  3,4 -> 2 집 타입을 이렇게 묶을 것
ifelse(user_data$house_type==1 | user_data$house_type==2, 1, 2)
user_data$house_type2 <-
table(user_data$house_type2)
user_data$house_type2 <-
table(user_data$house_type2)
user_data$house_type2 <- ifelse(user_data$house_type==1 | user_data$house_type==2, 1, 2)
table(user_data$house_type2)
#//나눠서 표시
tmp<- ifelse(user_data$house_type==1 | user_data$house_type==2, 1, 2)
user_data$house_type2 <- tmp
table(user_data$house_type2)
# 2) 1:n : 기존칼럼 -> 새로운 칼럼(n)
# 지불정도 테이블
pay_data <- read.csv("pay_data.csv")
str(pay_data)
names(pay_data)
library(dplyr)
library(reshape2)
product_price <- dcast(pay_data, user_id ~ product_type, #100 x 5행렬이 만들어짐
product_price <- dcast(pay_data, user_id ~ product_type, #100 x 5행렬이 만들어짐
sum)
product_price
#고객별 상품유형에 따른 구매금액 합계
product_price <- dcast(pay_data, user_id ~ product_type, #100 x 5행렬이 만들어짐
sum)
product_price
dim(product_price)
names(product_price) <- c("user_id", "식료품(1)", "생필품(2)",
"의류(3)", "잡화(4)", "기타(5)")
head(product_price)
# 3) 파생변수 추가(join)
library(dplyr)
# 형식) left_join(df1, df2, by='컬럼명(join대상이 된 공통 컬럼)')
user_pay_data <- left_join(user_data, product_price, by="user_id")
user_pay_data
head(user_pay_data)
dim(user_pay_data)
# 4) 사칙연산 : 총구매금액
names(user_pay_data)
user_pay_data$tot_price <- user_pay_data[7]+user_pay_data[8]+user_pay_data[9]+user_pay_data[10]+user_pay_data[11]
head(user_pay_data)
user_pay_data$tot_price <- user_pay_data[7]+user_pay_data[8]+user_pay_data[9]+user_pay_data[10]+user_pay_data[11]
head(user_pay_data)
# 4) 사칙연산 : 총구매금액
names(user_pay_data)
user_pay_data$tot_price <- user_pay_data[7]+user_pay_data[8]+user_pay_data[9]+user_pay_data[10]+user_pay_data[11]
head(user_pay_data)
head(user_pay_data[12])
head(user_pay_data)
user_pay_data$tot_price <- user_pay_data[,7]+user_pay_data[,8]+user_pay_data[,9]+user_pay_data[,10]+user_pay_data[,11]
head(user_pay_data)
str(user_pay_data)
user_data <- read.csv('user_data.csv')
return_data <- read.csv('return_data.csv')
head(user_data)
head(return_data)
names(return_data)
return_data$return_code2[return_data$return_code==1] <- "1.제품이상"
return_data$return_code2[return_data$return_code==2] <- "2.변심"
return_data$return_code2[return_data$return_code==3] <- "3.원인불명"
return_data$return_code2[return_data$return_code==4] <- "4.기타"
head(return_data)
user_data$return_code2 <- return_data$return_code2
user_data$return_code2 <- return_data$return_code2
library(reshape2)
#고객별 반품현황 : 집계함수(length)
return_code <- dcast(return_data, user_id ~ return_code, length)
return_code
library(dply)
#<조건2>
library(dply)
user_return_data <- left_join(user_data, return_code,
by='user_id')
head(usre_return_data,10)
user_data <- read.csv('user_data.csv')
return_data <- read.csv('return_data.csv')
head(user_data)
head(return_data)
####################################
library(reshape2)
#고객별 반품현황 : 집계함수(length)
return_code <- dcast(return_data, user_id ~ return_code, length)
return_code
# 칼럼 수정
names(return_code) <- c("return_code1","return_code2","return_code3","return_code4")
#<조건2>
library(dply)
user_return_data <- left_join(user_data, return_code,
by='user_id')
head(usre_return_data,10)
head(user_return_data,10)
install.packages("lattice")
library(lattice)
install.packages("mlmRev")
library(mlmRev)
data(Chem97)
# 1.histogram(~x축, dataframe)
histogram(~gcsescore, data=Chem97)
# score 변수를 조건으로 지정
histogram(~gcsescore | score, data=Chem97) # score 단위
histogram(~gcsescore | factor(score), data=Chem97) # score 요인 단위
Chem97
str(Chem97)
table(Chem97$score)
# score 변수를 조건으로 지정
histogram(~gcsescore | score, data=Chem97) # score 단위 |뒤에는 범주형변수를 넣는다.
histogram(~gcsescore | factor(score), data=Chem97) # score 요인 단위 // 팩터형으로 바꿔서
# 2.densityplot(~x축 | 조건, dataframe, groups=변수)
densityplot(~gcsescore | factor(score), data=Chem97,
groups = gender, plot.points=T, auto.key = T)
# 3.barchart(y~x | 조건, dataframe, layout)
barchart(Var1 ~ Freq | Var2, data=dft, layout=c(4,1)) #격자를 4,1로 하겠다는 것
# matrix -> data.table 변환
dft <- as.data.frame.table(VADeaths)
str(dft) # 'data.frame':  20 obs. of  3 variables:
class(dft) # "data.frame"
# 3.barchart(y~x | 조건, dataframe, layout)
barchart(Var1 ~ Freq | Var2, data=dft, layout=c(4,1)) #격자를 4,1로 하겠다는 것
barchart(Var1 ~ Freq | Var2, data=dft, layout=c(2,2)) #격자를 2,2로 하겠다는 것
